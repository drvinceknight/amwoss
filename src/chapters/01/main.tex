\chapter[Introduction]{Introduction}

\chapterinitial{T}{hank} you for starting to read this book. This book aims to
bring together two fascinating topics:

\begin{itemize}
\item
  Problems that can be solved using mathematics;
\item
  Software that is free to use and change.
\end{itemize}

What we mean by both of those things will become clear through reading
this chapter and the rest of the book.

\section{Who is this book for?}\label{sec:who-is-this-book-for}

This book is aimed at readers who want to use open-source software to solve the
considered applied mathematical problems.

If you are a student of a mathematical discipline, a graduate student of
a subject like operational research, a hobbyist who enjoys solving the
travelling salesman problem or even if you get paid to do this stuff:
this book is for you. We will introduce you to the world of open-source 
software that allows you to do all these things freely.

If you are a student learning to write code, a graduate student using
databases for their research, an enthusiast who programs applications
to help schedule weekly chores, or even if you get paid to
write software: this book is for you. We will introduce you to a world
of problems that can be solved using your skill set.

It would be helpful for the reader of this book to:

\begin{itemize}
\item
  Have access to a computer and be able to connect to the internet
  to be able to download the relevant software;
\item
  Have done any introductory tutorial in the languages they plan to use;
\item
  Be prepared to read some mathematics.
  The topics covered use some algebra, calculus and probability.
  Technically you do not need to
  understand the specific mathematics to be able to use the tools in this book.
\end{itemize}

By reading a particular chapter of the book, the reader will have:

\begin{enumerate}
  \item the practical knowledge to solve problems using a computer;
  \item an overview of the higher level theoretic concepts;
  \item pointers to further reading to gain background understand and research
        undertaken using the concepts.
\end{enumerate}

\section{What do we mean by applied mathematics?}\label{sec:what-do-we-mean-by-applied-mathematics}

We consider this book to be a book on applied mathematics. This is not
however a universal term, for some applied mathematics is the study of
mechanics and involves things like modelling projectiles being fired out of canons.
We will use the term a bit more freely here and mean any type of real
world problem that can be tackled using mathematical tools. This is
sometimes referred to as operational research\index{operational research},
operations research, mathematical modelling or indeed just mathematics.

One of the authors, Vince, used mathematics to understand just how bad one of
the so called ``worst plays in Super Bowl\index{Super Bowl} history was''. Using
an area of mathematics called game theory\index{game theory} (seen in
Chapter~\ref{chp:game_theory}) he showed that perhaps the strategic decision
making was not as bad as it seemed, the outcome was just unlikely\footnote{At
the time of writing this is available to read at:
\url{https://vknight.org/unpeudemath/gametheory/2015/02/15/on-the-worst-play-in-superbowl-history.html}}.

The other author, Geraint, used mathematics to find the best team of
Pokémon\index{Pokémon}. Using an area of mathematics called linear
programming\index{linear programming} (seen in
Chapter~\ref{chp:linear_programming}) which is based on linear algebra he was
able to find the best makeup of Pokémon\footnote{At the time of writing this is
available to read at:
\url{http://www.geraintianpalmer.org.uk/2018/05/29/pokemon-team-pulp/}}.

Here, applied mathematics is the type of mathematics that helps us
answer questions that the real world asks.

\section{What is open-source software}
\label{sec:what-is-open-source-software}

Strictly speaking open-source software\index{open-source software} is software
with source code that anyone can read, modify and improve. In practice this
means that you do not need to pay to use it which is often one of the first
attractions.
This financial aspect can also be one of the reasons that someone will
not use a particular piece of software due to a confusion between cost
and value: if something is free is it really going to be any good?

In practice open-source software is used all over the world and powers
some of the most important infrastructure around.
A good example of this is cryptographic software which should not rely on
secrecy for security\footnote{This
is also referred to as Kerckhoffs's\index{Kerckhoffs} principle which states
that ``a cryptosystem should be secure, even if everything about the system,
except the key, is public knowledge''~\cite{kerckhoffs1883cryptographie}}. This
implies that cryptographic systems that do not require trust in a hidden system
can exist.
In practice these are all open-source.

Today, open-source software is a lot more than a licensing agreement:
it is a community of practice. Bugs are fixed faster, research is
implemented immediately and knowledge is spread more widely thanks to
open-source software. Bugs are fixed faster because anyone can read and
inspect the source code. Most open-source software projects also have
clear mechanisms for communicating with the developers and even
reviewing and accepting code contributions from the general public.
Research is implemented immediately because when new algorithms are
discovered they are often added directly to the software by the
researchers who found them. This all contributes to the spread of
knowledge: open-source software is the modern shoulder of giants that
we all stand on.

Open source software is software that, like scientific knowledge is not
restricted in its use.

\section{How to get the most out of this
book}\label{sec:how-to-get-the-most-out-of-this-book}

The book itself is open-source. You can find the source files for this
book online at \url{https://github.com/drvinceknight/ampwoss}. There will
also find a number of \emph{Jupyter notebooks}\index{Jupyter} and \emph{R markdown
files}\index{R markdown} that include code snippets that let you follow along.

We feel that you can choose to read the book from cover to cover,
writing out the code examples as you go; or it could also be used as a
reference text when faced with a particular problem and wanting to know
where to start.

After this introductory chapter the book is split in to 4 sections.
Each section corresponds to a broad problem type and contains 2 chapters that
correspond to 2 solution approaches. The first chapter in a section is based on
exact methodology whereas the second chapter is based on heuristic
methodology.
The structure of the book is:

\begin{enumerate}
    \item Probabilistic modelling
        \begin{itemize}
                \item Markov chains
                \item Discrete event simulation
        \end{itemize}
    \item Dynamical systems
        \begin{itemize}
                \item Differential equations
                \item Systems dynamics
        \end{itemize}
    \item Emergent behaviour
        \begin{itemize}
                \item Game theory.
                \item Agent based simulation
        \end{itemize}
    \item Optimisation.
        \begin{itemize}
                \item Linear programming
                \item Heuristics
        \end{itemize}
\end{enumerate}

Every chapter has the following structure:

\begin{enumerate}
\item
  Introduction - a brief overview of a given problem type. Here we will
  describe the problem at hand in general terms.
\item
  An example problem. This will provide a tangible example problem that
  offers the reader some intuition for the rest of the discussion.
\item
  An overview of the theory as well as a discussion as to how the theory relates
  to the considered problem. Readers will also be presented with reference
  texts if they want to gain a more in depth understanding.
\item
  Solving with Python. We will describe how to use tools available
  in Python to solve the problem.
\item
  Solving with R. We will describe how to use tools available
  in R to solve the problem.
\item
  The wider context. This section will include a few hand picked academic papers
  relevant to the covered topic. It is hoped that these few papers can be a good
  starting point for someone wanting to not only use the methodology described
  but also understand the broader field.
\end{enumerate}

For a given reader, not all sections of a chapter will be of interest.
Perhaps a reader is only interested in R and finding out more about the
research.
The R and Python sections are \textbf{purposefully} written as near clones of
each other so that a reader can read only the section that interests them.
In places there are some minor differences in the text and this is due to
differences of implementation in the respective languages.

Note that the solution proposed to each problem in each chapter is not
necessarily unique. For example, in Chapter~\ref{chp:discrete_event_simulation}
the Python library Ciw\index{Ciw}~\cite{ciwpython, palmer2019ciw}
is used whereas an alternative could be to use a Python
library called SimPy\index{SimPy}~\cite{simpy}.

Please do take from the book what you find useful.

\section{How code is written in this book}\label{sec:how-code-is-written-in-this-book}

Throughout this book, there are going to be various pieces of code written. Code
is a series of instructions that usually give some sort of output when submitted
to a computer.

This book will show both the set of instructions (referred to as the input) and
the output.

You will see Python input as follows:

\begin{pyin}
print(2 + 2)
\end{pyin}

and you will see Python output as follows:

\begin{pyout}
4
\end{pyout}

You will see R input as follows:

\begin{Rin}
print(2 + 2)
\end{Rin}

and you will see R output as follows:

\begin{Rout}
[1] 4
\end{Rout}

As well as this, a continuous line numbering across all code sections is used so
that if the reader needs to refer to a given set of input or output this can be
done.

The code itself is written using 3 principles:

\begin{itemize}
          \item Modularity\index{modularity}: code is written as a
              series of smaller sections of code. These correspond to smaller,
              simpler, individual tasks (modules) that can be used together to
              carry out a particular larger task.
          \item Documentation\index{documentation}: readable variable names as
              well as
              text describing the functionality of each module of code are used
              throughout. This ensures that code is not only usable but also
              understandable.
          \item Tests\index{tests}: there are places where each module of code is
              used independently to check the output. This can be thought of as a
              test of functionality which readers can use to check they are
              getting expected results.
\end{itemize}

These are best practice\index{best practice} principles in research software
development that ensure usable, reproducible and reliable
code~\cite{wilson2014best}. Interested readers might want to see
Figure~\ref{fig:rsd-triangle} which shows how the 3 principles interact with
each other.

\begin{figure}
    \begin{center}
        \includestandalone[width=.8\textwidth]{./assets/rsd-triangle/main}
        \caption{The relationship between modularisation, documentation and
            testing. The authors thank Dr Nikoleta E. Glynatsi for their
            contribution to the drawing of this diagram.}
        \label{fig:rsd-triangle}
    \end{center}
\end{figure}

Thank you for picking up this book, we hope one if not all of the following
chapters proves interesting or useful to you.
